{
  "code": "import threading #thread module imported\nfrom socket import *\nimport struct\nimport binascii\nimport re\nimport time\n\ndestinies = {}\n\ndef unpackFrameEthernet(frame):\n    destiny, origin, protocol = struct.unpack('! 6s 6s H', frame[:14])\n    return bytesToHexa(destiny), bytesToHexa(origin), htons(protocol), frame[14:]\n\ndef bytesToHexa(bytes_address):\n    hex_list = []\n    address = binascii.hexlify(bytes_address).decode(\"ascii\")\n    for i in range(0,12,2):\n        hex_list.append(address[i:i+2])\n    mac = \":\".join(hex_list)\n    return mac\n\ndef socketStart(net_interface):\n    Socket = socket(AF_PACKET, SOCK_RAW, htons(3))\n    Socket.bind((net_interface, 0))\n    return Socket\n\ndef ipPacketData(data):\n    ip_data_tuple = struct.unpack(\"!BBHHHBBH4s4s\", data[:20])\n    version = ip_data_tuple[0]\n    header_len = version >> 4\n    service_type = ip_data_tuple[1]\n    total_size = ip_data_tuple[2]\n    identifier = ip_data_tuple[3]\n    offset_fragment = ip_data_tuple[4]\n    life_time_ttl = ip_data_tuple[5]\n    protocols = ip_data_tuple[6]\n    checksum_header = ip_data_tuple[7]\n    ip_origin = inet_ntoa(ip_data_tuple[8])\n    ip_destiny = inet_ntoa(ip_data_tuple[9])\n\n    header_size_bytes = (version & 15) * 4\n    return ip_origin, ip_destiny, data[header_size_bytes:]\n\ndef dados_pacote_udp(carga):\n    tupla_dados_udp = struct.unpack('! H H H H', carga[:8])\n    porta_fonte = tupla_dados_udp[0]\n    porta_destino = tupla_dados_udp[1]\n    udp_len = tupla_dados_udp[2]\n    udp_checksum = tupla_dados_udp[3]\n    \n    return porta_fonte, porta_destino, udp_len, udp_checksum, carga[8:]\n\ndef saveInfos():\n    \"\"\"Funcao que salva as informacoes obtidas pelo algoritmo em um arquivo .csv de saida\"\"\"\n    global n_dropped, n_transmitted, outputFile, outputFileTimes\n\n    saida = '{};{};\\n'.format(n_transmitted, n_dropped)\n    outputFile.write(saida)\n    outputFile.close()\n    outputFileTimes.write('\\n')\n    outputFileTimes.close()\n    semaphore.release()\n    exit()  \n\ndef threadDpi():\n    \"\"\" Thread do LeakyBucket que ao receber um pacote enfileira, \n    transmite ou descarta o pacote, de acordo com seus parametros\"\"\"\n    global clientSocket, semaphore, debug, n_dropped, n_transmitted, n_packet, outputFileTimes\n\n    while 1:\n        contentReceived = clientSocket.recv(65535)\n        mac_destino, mac_fonte, protocolo, carga_util = unpackFrameEthernet(contentReceived)\n        ipOrigem, ipDestino, dados = ipPacketData(carga_util)\n        porta_fonte, porta_destino, udp_len, udp_checksum, carga = dados_pacote_udp(dados)\n        if debug: \n            total =  n_transmitted + n_dropped\n            if total >= 1000:\n                exit()\n        if '10.0.1.101' in ipDestino:\n            stime = time.time()\n            patternFind = re.search(\"Estou infectado\", carga.decode(\"utf-8\"))\n            if (not patternFind):\n                senderSocket_h1.send(contentReceived)\n                if debug:\n                    print(\"Transmitindo pacote\")\n                    n_transmitted += 1\n                    etime = time.time()\n                    saida = '{};'.format(etime - stime)\n                    outputFileTimes.write(saida)\n                    total =  n_transmitted + n_dropped\n                    if total >= 1000:\n                        saveInfos()\n            else:\n                if debug:\n                    print(\"Pacote infectado, descartando\")\n                    etime = time.time()\n                    saida = '{};'.format(etime - stime)\n                    outputFileTimes.write(saida)\n                    n_dropped += 1\n                    total =  n_transmitted + n_dropped\n                    if total >= 1000:\n                        saveInfos()\n            n_packet += 1\n        semaphore.release()\n\ninterval = 1\ndebug = 1\nn_packet = 0\n\nif debug:\n    n_transmitted = 0\n    n_dropped = 0\n    outputFile = open('/home/felipe/Desktop/testesMestrado/dpi.csv', 'a')\n    outputFileTimes = open('/home/felipe/Desktop/testesMestrado/dpiTimes.csv', 'a')\n\n\nclientSocket = socketStart('veth-ch0')\nsenderSocket_h1 = socketStart('veth-h1')\n\nsemaphore = threading.Semaphore(1)\ndpi = threading.Thread(target=threadDpi, args=())\n\ndpi.start()\n\n",
  "interfacesNumber": 2,
  "traffics": [
    {
      "type": "Personal",
      "name": "Personal Traffic Generator",
      "code": "from socket import *\nimport time\nimport threading\nimport random\nrandom.seed(10)\n\ndef thread_Traffic(thread_name, interval, msg):\n    global clientSocket, addr_1, startMessage, middleMsg, endMsg\n    n_packet = 0\n    while n_packet < 1000:\n        number = random.randint(0, 100)\n        if number >= 60:\n            clientSocket.sendto(msg, addr_1)\n        else:\n            if (number % 3) == 0:\n                clientSocket.sendto(startMessage, addr_1)\n            elif (number % 3) == 1:\n                clientSocket.sendto(middleMsg, addr_1)\n            elif (number % 3) == 2:\n                clientSocket.sendto(endMsg, addr_1)\n        n_packet += 1\n        time.sleep(interval)\n\nmessage = b'Estou limpo' + (b'.' * 1013)\nstartMessage = b'Estou infectado'\nstartMessage += b\".\" * (1024 - len(startMessage))\nmiddleMsg = b\".\" * 512\nmiddleMsg += b\"Estou infectado\" * (1024 - len(middleMsg) - 512)\nendMsg = b\".\" * 1009\nendMsg += b\"Estou infectado\"\n\naddr_1 = (\"10.0.1.101\", 8001)\n\nclientSocket = socket(family=AF_INET, type=SOCK_DGRAM)\nclientSocket.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)\nclientSocket.bind(('10.2.2.100', 8001))\n\nthreadTraffic = threading.Thread(target=thread_Traffic, args=('traffic_sender', 0.04, message))\n\nthreadTraffic.start()\n"
    }
  ]
}